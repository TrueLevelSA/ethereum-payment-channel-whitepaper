% This is based on the LLNCS.DEM the demonstration file of % the LaTeX macro
% package from Springer-Verlag % for Lecture Notes in Computer Science, version
% 2.4 for LaTeX2e as of 16. April 2010
%
% See http://www.springer.com/computer/lncs/lncs+authors?SGWID=0-40209-0-0-0
% for the full guidelines.
\documentclass{llncs}
\usepackage{graphicx}
\graphicspath{ {./assets/} }

\usepackage{enumitem}
\setlist[enumerate]{itemsep=2mm}

\usepackage{dirtytalk}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{pdflscape}
\usepackage[pass]{geometry}

%
% Tables
% --------
\usepackage[table]{xcolor}
\usepackage{hhline}
\usepackage{booktabs} % much better tables
\usepackage{multirow} % allows to fuse rows
\usepackage{array}    % manipulate array
\usepackage{tabularx} % better tables

% Define new tabularx column types:
%  - R: streteched right aligned
%  - C: stretched centered
%  - N: left aligned, specified space
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\newcolumntype{N}[1]{>{\raggedleft\arraybackslash}p{#1}}
\newcolumntype{S}{>{\hsize=.5\hsize}C}

% Set row height multiplicator to provide more breathing space
\renewcommand{\arraystretch}{1.5}

\usepackage[backend=biber]{biblatex}
\addbibresource{bibliography.bib}

\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{arabic}

\begin{document}

\title{Multi-client Partially Non-Interactive and Instantaneous One-way Payment Channel for Ethereum}
\author{Thomas Shababi\inst{1} \and Jo\"el Gugger\inst{1} \and Daniel Lebrecht\inst{1}}

\authorrunning{Thomas~S.~Shababi et al.}
\tocauthor{Thomas~S.~Shababi, Joel Gugger, and Daniel Lebrecht}
\subtitle{{\normalsize\today{\small\ -- DRAFT}}}
\institute{TrueLevel SA, Neuch\^atel, Switzerland\\ \email{\{tom, joel, d\}@truelevel.io}}

\maketitle

\begin{abstract} Ethereum is a distributed computing platform and operating system featuring smart contract functionality. Transactions are faster than other blockchain but not instant and each of them cost some ``gas''. This gas is used to quantify the amount of fee to pay for computation. \keywords{Crypto-currencies, Ethereum, Payment channels}
\end{abstract}

\section{Introduction} 

\section{Multi-clients payment channels} Partially non-interactive multi-clients payment channels are composed of clients $c \in \mathcal{C}$ and one provider $\mathcal{P}$. $\mathcal{C}$ is the set of all clients registred in the multi-clients payment channel. Clients can send money to the provider through the channel $c \rightarrow \mathcal{P}$ but cannot recieve through the channel $\mathcal{P} \not\rightarrow c$.

A payment channel is by definition a structure composed of two layers of states. The first layer of states is registered to the blockchain, i.e. ``on-chain'' or contract states $\mu \in M$, and the second layer of states is kept ``off-chain'' between the participants, i.e. channel states $\sigma \in \Sigma$.

It is possible to transition from a state $\sigma$ to another state $\sigma'$. We denote state transition with $\rightarrow$, i.e. $\sigma \rightarrow \sigma'$.  Modifiers $\omega \in \Omega$ are used to create transition on channel states $\sigma \in \Sigma$. A transition in $\Sigma$ depends on modifiers and contract states. We denote a transition from $\sigma, \sigma' \in \Sigma$ that depends on $\mu \in M$ and $\omega \in \Omega$ as
$$\sigma \xrightarrow{\mu+\omega} \sigma'$$

Contract state transitions are triggered by external events $e \in \mathcal{E}$ or messages $m \in \mathcal{M}$. Transitions between two states $\mu, \mu' \in M$ are denoted $\mu \rightarrow \mu '$. If the transition is due to an external event $e$ we write $\mu \xrightarrow{e} \mu '$. If the transition is due to a message $m$ we write $\mu \xrightarrow{m} \mu '$. Generic transitions are noted as $\mu \rightarrow \mu '$.

A message $m$ can be ``applied'' to a state $\mu$, we denote this operation with $m(\mu)$, i.e. $\mu \xrightarrow{m} \mu'$. Messages are created based on a channel states. Each channel state $\sigma \in \Sigma$ can derive its corresponding message $m \in \mathcal{M}$
$$\forall \sigma \in \Sigma,\ \exists m\ |\ m \in \mathcal{M}$$

In reality it is not necessary to derive all messages. External events (top ups) afect the channel state but no messages are created because the previous generated message is still valid and usable to trigger a valid state transition in $M$.

\subsection{Contract state variables} We define variables to acces the the contract state $\mu \in M$ for a client $c \in \mathcal{C}$.

\subsubsection{Current on-chain index, $I(c)$} For each client the current index $i$ must be retreivable, $\forall c \in \mathcal{C}, \quad \exists I(c) \in \mu >= 0$. The index for a client must start from $0$.

\subsubsection{Current on-chain balance, $B_\mu(c)$} For each client the current balance amount must be retreivable, $\forall c \in \mathcal{C}, \quad \exists B_\mu(c) \in \mu >= 0$.

\subsection{Contract states} Each client $c \in \mathcal{C}$ in the contract is defined by an on-chain state $\mu \in M$. States $\mu \in M$ are a tuple
$$(I(c), B_\mu(c))$$

\subsection{Channel state variables} We define variables to represent: (i) the lifetime of a single channel in the multi-clients channel architecture, (ii) the total amount deposited for a client over the lifetime, (iii) the total amount own by the provider over the lifetime, and (iv) the minimal and full available amount for the client.

\subsubsection{Channel lifetime, $L(c \rightarrow \mathcal{P})$} It exists one lifetime and only one per element in $\mathcal{C} \times \mathcal{P}$ and begins when the first deposit is made, i.e. one lifetime per client $c \in \mathcal{C}$.

\subsubsection{Total deposit, $D(c)$} Total deposit of a client $c$ represents the total amount recieved from the begining of the lifetime. Each top up increases the total deposit.

\subsubsection{Total sent, $\sum c \rightarrow \mathcal{P}$} Total amount sent to the provider by a client $c$ represents the sum of all transaction since the begining of the lifetime. Each transaction increases the total sent.

\subsubsection{Minimal available amount, $A_m(c)$} Minimal amount available for a client $c$ is computed with the latest channel state $\sigma$. Without quering the contract state $\mu$ it is impossible to know if a bigger amount is now available. The minimal available amount is computed with
$$A_m(c) = D(c) - \textstyle \sum c \rightarrow \mathcal{P}$$

\subsubsection{Client available amount, $A(c)$} The full amount available into a single channel for a client $c \in \mathcal{C}$ is computed with
$$A(c) = D(c) - \textstyle \sum c \rightarrow \mathcal{P} + (B_\mu(c) - B_\sigma(c)), \quad B_\mu(c) \geq A(c)$$

It is worth noting that $B_\mu(c) - B_\sigma(c)$ is added to the difference of total deposit and total sent in case of on-chain changements, like top up.

\subsection{Channel states} Each client $c \in \mathcal{C}$ is defined by their channel state $\sigma \in \Sigma$. States $\sigma \in \Sigma$ are composed of: (i) a validity index, (ii) the latest observed on-chain balance
of the client, (iii) the total deposit of the client, and (iv) the total owned by the provider. We denote a state $\sigma \in \Sigma$ as
$$(i, B_\sigma(c), D(c), \textstyle \sum c \rightarrow \mathcal{P})$$

\subsection{Messages} Messages $m \in \mathcal{M}$ are exchanged between clients $\mathcal{C}$ and provider $\mathcal{P}$. A message is related to one and only one element in $\mathcal{C} \times \mathcal{P}$.

\subsubsection{Minimal message} A minimal message $m \in \mathcal{M}$ between a client $c$ and the provider $\mathcal{P}$ is composed of four components: (i) a validity index, (ii) the lastest observed balance, (iii) the total of deposit, and (iv) the total owned by the provider. We denote a message $m \in \mathcal{M}$ as
$$(i, B_\sigma(c), D(c), \textstyle \sum c \rightarrow \mathcal{P})$$

\subsubsection{Message derivation} Messages are derived from channel states $\Sigma$ as
\begin{equation*}
\begin{split}
    \sigma &\implies m \\
    (i, B_\sigma(c), D(c), \textstyle \sum c \rightarrow \mathcal{P}) &\implies (i+1, B_\sigma(c), D(c), \textstyle \sum c \rightarrow \mathcal{P}) \\
\end{split}
\end{equation*}

\subsection{Modifiers} Modifiers $\omega \in \Omega$ are input parameters that modify channel states $\sigma$. They encapsulate the channel capabilities. In this multi-clients payment channel the capability is sending money through the channel from clients to provider, i.e. $c \rightarrow \mathcal{P}$.

\subsubsection{Payment, $\omega(a)$} This modifier is used to increase the balance $O(\mathcal{P})$ of the provider of $a$ amount from a client $c$.

\section{State transitions}

\subsection{Contract state, $\mu \rightarrow \mu'$} Contract states $\mu \in M$ can transition $\mu \rightarrow \mu'$ because of a message $m \in \mathcal{M}$ or external events.

\subsubsection{Settlement} $(i, B_\mu(c)) \xrightarrow{m} (i+1, B_\mu(c)\downarrow)\ |\ m = (i+1, B_\sigma(c), D(c), \sum c \rightarrow \mathcal{P})$. It is worth noting that with this rule it is not possible to settle a zero amount because the balance amount $B_\mu(c)$ must go down!
\begin{equation*}
\begin{split}
    O(\mathcal{P}) &= B_\mu(c) - A(c) \\
    &= B_\mu(c) - (D(c) - \textstyle \sum c \rightarrow \mathcal{P} + (B_\mu(c) - B_\sigma(c))) \\
\end{split}
\end{equation*}

$O(\mathcal{P})$ is the amount owned by the provider at the settlement time. The provider can settle the amount in the balance minus the remaining funds of the client $c$.
\begin{equation*}
\begin{split}
    B_\mu(c)\downarrow \ &= B_\mu(c) - O(\mathcal{P}) \\
    &= B_\mu(c) -(B_\mu(c) - (D(c) - \textstyle \sum c \rightarrow \mathcal{P} + (B_\mu(c) - B_\sigma(c)))) \\
\end{split}
\end{equation*}

The new client balance is the current contract balance minus the the amount due to the provider.

\subsubsection{Full refund} $(i, B_\mu(c)) \xrightarrow{m} (i+1, 0)\ |\ m = (i+1, B_\sigma(c), D(c), \sum c \rightarrow \mathcal{P})$. It is a full refund if the client available funds in the channel for the client are equal to the current contract balance
\begin{equation*}
\begin{split}
    B_\mu(c) &\overset{?}{=} A(c) \\
    &\overset{?}{=} D(c) - \textstyle \sum c \rightarrow \mathcal{P} + (B_\mu(c) - B_\sigma(c)) \\
\end{split}
\end{equation*}

\subsubsection{Partial refund} $(i, B_\mu(c)) \xrightarrow{m} (i+1, 0)\ |\ m = (i+1, B_\sigma(c), D(c), \sum c \rightarrow \mathcal{P})$. It is a partial refund if the client available funds in the channel are smaller than the current contract balance
\begin{equation*}
\begin{split}
    B(c) &\overset{?}{>} A(c)
\end{split}
\end{equation*}

In that case the provider amount is
\begin{equation*}
\begin{split}
    O(\mathcal{P}) &= B_\mu(c) - A(c)
\end{split}
\end{equation*}

\subsubsection{Top up} $(i, B_\mu(c)) \xrightarrow{e} (i, B_\mu(c)\uparrow)$. Top up increases the contract balance for a client $c \in \mathcal{C}$. Validity index $i$ must not be incremented during the top up.

\subsubsection{Invalid settlement} $(i, B_\mu(c)) \rightarrow (i, B_\mu(c)\downarrow)$. This transition is invalid because the balance is decreased without incrementing the validity index $i$. The current set of transactions must be invalidate after the settlement.

\subsubsection{Invalid top up} $(i, B_\mu(c)) \rightarrow (i+1, B_\mu(c)\uparrow)$ Increasing validity index $i$ while increasing the contract balance invalidates the set of transaction $i$. The current set of transactions must be invalidate only during a settlement.

\subsubsection{Invalid validity index} $(i, B_\mu(c)) \rightarrow (i\downarrow, \_)$ Decreasing the validity index $i$ is always invalid. Validity index must not be decreased.

\subsection{Channel state, $\sigma \rightarrow \sigma'$} Channel state transitions $\sigma \xrightarrow{\mu + \omega} \sigma'$ for $\sigma, \sigma' \in \Sigma$, i.e. applying a modifier $\omega$ on the current state $\mu$ to result on $\sigma'$. The contract state $\mu$ must be query on-chain. The base channel state is
\begin{equation*}
\begin{split}
  \sigma &=
  \begin{cases}
    \emptyset & \quad \text{if no previous state exists} \\
    (i, B_\sigma(c), D(c), \textstyle \sum c \rightarrow \mathcal{P}) & \quad \text{otherwise}
  \end{cases}
\end{split}
\end{equation*}

\subsubsection{Payment, $\mu(I(c), B_\mu(c))+\omega(a)$} Payments trigger transition in channel states from a base state $\sigma$ to a destination state $\sigma'$ noted $\sigma \xrightarrow{\mu + \omega(a)} \sigma'$.
The destination state is computed as
\begin{equation*}
\begin{split}
  \sigma' &=
  \begin{cases}
      (I(c), B_\mu(c), B_\mu(c), a) & \quad \text{if } \sigma = \emptyset \\
      (I(c), B_\mu(c), D(c), \textstyle \sum c \rightarrow \mathcal{P}+a) & \quad \text{otherwise}
  \end{cases}
\end{split}
\end{equation*}

\subsubsection{Top up, $\mu(I(c), B_\mu(c) \uparrow)$} Each top up event modify the contract state $\mu$, then the channel state $\sigma$ must be updated to keep track of the real balance.
\begin{equation*}
\begin{split}
  \sigma' &=
  \begin{cases}
      (I(c), B_\mu(c), B_\mu(c), 0) & \quad \text{if } \sigma = \emptyset \\
      (I(c), B_\mu(c), D(c) + (B_\mu(c) - B_\sigma(c)), \textstyle \sum c \rightarrow \mathcal{P}) & \quad \text{otherwise}
  \end{cases}
\end{split}
\end{equation*}
%\section{Protocol} The protocol describe valid and invalid actions for clients and the provider, rules for state transition, and messages.
%
%\subsubsection{Client actions} A client can send money through the channel, authorize limited payment, and refund his money.
%
%\subsubsection{Provider actions} The provider can settle a single channel, and ``settle and close'' a single channel.
%
%\subsection{Send money, $c \rightarrow \mathcal{P}$} Two messages are generated: (i) a refund message for the client, and (ii) a settle message for the provider.
%
%\subsubsection{Refund message, $m_r$} Refund message $m_r$ must allow the client to claim his remaing funds $A(c \rightarrow \mathcal{P})$ and transfer them after some locktime if the provider does not dispute the refund. 
%
%\subsubsection{Settle message, $m_s$}
%
%
%\section{Acknowledgement} Loan Ventura, Thomas Roulin and Nicolas Huguenin are acknowledged for their helpful contribution and comments during the completion of this work.

\begin{table}[t]
  \begin{tabularx}{\textwidth}{| S | S | C | C | C |}
    \cline{2-5}
      \multicolumn{1}{c|}{ } & $\omega$ & $\mu$ & $m$ & $\sigma$ \\ \cline{2-5}
      \multicolumn{1}{c|}{ } & $\omega(a)$ & $(I(c), B_\mu(c))$ & $(i, B_\sigma(c), D(c), \sum)$ & $(i, B_\sigma(c), D(c), \sum)$ \\
  \hhline{-====}
      init & & $(0,10)$ & & $\emptyset$ \\
      transact & $+1$ & & $(1, 10, 10, 1)$& $(0, 10, 10, 1)$ \\
      transact & $+1$ & & $(1, 10, 10, 2)$& $(0, 10, 10, 2)$ \\
      settle & & (1,8) & & \\
      transact & $+2$  & & $(2, 8, 10, 4)$ & $(1, 8, 10, 4)$ \\
      transact & $+2$  & & $(2, 8, 10, 6)$ & $(1, 8, 10, 6)$ \\
      top up & & (1,18) & & $(1, 18, 20, 6)$ \\
      transact & $+1$ & & $(2, 18, 20, 7)$ & $(1, 18, 20, 7)$ \\
      settle & & (2,13) & & \\
      \cline{1-5}
  \end{tabularx}
  \medskip
  \caption{State transitions during channel lifetime}
\end{table}


\begin{table}[t]
  \begin{tabularx}{\textwidth}{| S | S | C | C | C |}
    \cline{2-5}
      \multicolumn{1}{c|}{ } & $\omega$ & $\mu$ & $m$ & $\sigma$ \\ \cline{2-5}
      \multicolumn{1}{c|}{ } & $\omega(a)$ & $(I(c), B_\mu(c))$ & $(i, B_\sigma(c), D(c), \sum)$ & $(i, B_\sigma(c), D(c), \sum)$ \\
  \hhline{-====}
      init & & $(0,3)$ & & $\emptyset$ \\
      top up & & (0,5) & & $(0, 5, 5, 0)$ \\
      transact & $+3$ & & $(1, 5, 5, 3)$ & $(0, 5, 5, 3)$ \\
      settle & & (1,2) & & \\
      transact & $+1$ & & $(2, 2, 5, 4)$ & $(1, 2, 5, 4)$ \\
      top up & & (1,4) & & $(1, 4, 7, 4)$ \\
      settle & & (2,3) & & \\
      transact & $+2$ & & $(3, 3, 7, 6)$ & $(2, 3, 7, 6)$ \\
      \cline{1-5}
  \end{tabularx}
  \medskip
  \caption{Settlement after top up}
\end{table}

%
% ---- Bibliography ----
%
\printbibliography

\end{document}
